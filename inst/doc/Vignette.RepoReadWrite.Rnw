\documentclass[
a4paper, % Stock and paper size.
11pt, % Type size.
article,
% oneside,
onecolumn, % Only one column of text on a page.
%openright%, % Each chapter will start on a recto page.
% openleft, % Each chapter will start on a verso page.
%openany, % A chapter may start on either a recto or verso page.
]{memoir}

%\usepackage{graphicx} 
%\usepackage{ifpdf}
%\ifpdf
%   % put here packages only for the PDF:
%   \DeclareGraphicsExtensions{.pdf,.pngi,.jpg,.mps}
%   \usepackage{hyperref}
%\else
%   % put here packages only for the DVI:
%\fi

% put all the other packages here:

\addtolength{\hoffset}{-1.3cm}
\addtolength{\textwidth}{3cm}


\usepackage[utf8]{inputenc} % If utf8 encoding
%\usepackage[latin1]{inputenc} % If not utf8 encoding, then this is probably the way to go
%\usepackage[T1]{fontenc}    %
%% Choose one of the following (if not choosing the default,
%% viz., Computer Modern, font family):
 \usepackage{palatino}
 %\usepackage{lmodern}
 %\usepackage{mathpazo}
 %\usepackage{kpfonts}
 %\usepackage{mathptmx}
 %\usepackage{times,mtpro2}
 %\usepackage{txfonts}
 %\usepackage{newtxtext,newtxmath}
 %\usepackage{libertine}
 %\usepackage[libertine]{newtxmath}

\usepackage[english, spanish, activeacute]{babel}
\usepackage{csquotes}
\usepackage{lscape}
\usepackage[final]{microtype} % Less badboxes

\usepackage{amsmath,amssymb,mathtools, cool} % Math

% \usepackage{tikz} % Figures
\usepackage{graphicx} % Include figures

\usepackage{graphicx} % Include figures

%%%% FLOW CHART with tikz
\usepackage{pstricks,pst-plot,pst-node,pst-text,pst-3d,pst-grad}
%\usepackage{treetex}
\usepackage{fancybox}
\usepackage{color}
\usepackage{textcomp}
\usepackage{qtree}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{trees,shapes,shadows,arrows, automata, positioning}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{shapes.multipart}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}

\tikzset{
    Texto/.style={
           draw=white, very thick,
           minimum height=1em,
           inner sep=2pt,
           text centered,
           },
}

\renewcommand{\abstractnamefont}{\normalfont\small\bfseries} % Font of abstract title
\setlength{\absleftindent}{0.1\textwidth} % Width of abstract
\setlength{\absrightindent}{\absleftindent}
\usepackage{hyperref}   % Internal hyperlinks
\hypersetup{
%pdfborder={0 0 0},      % No borders around internal hyperlinks
pdfauthor={David Salgado} % author
}
\usepackage{memhfixc}   %
%\usepackage{breakurl}

\counterwithout{section}{chapter}
\setsecnumdepth{subsection}
\newcommand{\nn}{\nonumber}

%%% BIBLIOGRAPHY
%%%-----------------------------------------------------------------------------
\usepackage[backend=bibtex8,citestyle=alphabetic,bibstyle=authoryear,sortlocale=sp,natbib=true,url=false]{biblatex}
\addbibresource{N:/UDMTD/UDTMDCOM/BIBLIO/BiblioStat}


\begin{document}
\SweaveOpts{concordance=TRUE}

 \selectlanguage{spanish}

    \begin{center}
    \LARGE{El paquete \textsf{RepoReadWrite}}
    \medskip

    \Large{Instituto Nacional de Estadística}

    \bigskip

    \today

    \end{center}



    \begin{abstract}
        Este documento describe el funcionamiento del paquete \textsf{ReadRepoWrite} para la lectura y escritura de ficheros en el repositorio de microdatos. Se detallan las funciones del paquete con ejemplos mostrando cómo pasar de un fichero SAS con la estructura tradicional de matriz de datos con unidades por filas y variables por columnas a un fichero con estructura par clave-valor acordada para los ficheros del repositorio. Análogamente se detalla el proceso inverso de lectura de un fichero del repositorio y su transformación a la estructura rectangular para su explotación.
    \end{abstract}


\section{Introducción: filosofía general del paquete}
 
 La filosofía general del paquete \textsf{RepoReadWrite} se representa en la figura \ref{fig:Tra}, que expresa las transformaciones entre los diversos formatos y almacenamientos de los ficheros del repositorio.\\
 
 En la figura, cada nodo representa un formato de fichero u objeto junto con el lenguaje empleado para su gestión (SAS, R o ASCII\footnote{En rigor, ASCII no es un lenguaje, sino una codificación de caracteres accesible a la casi totalidad de lenguajes de programación. Con ASCII, por tanto, nos referimos a que el fichero obedece a esta codificación y puede ser gestionado con cualquier otro lenguaje.}) y con su tipo de almacenamiento (en memoria principal o en disco).\\
 
 Los nodos están conectados a través de flechas que representan las diversas transformaciones posibles. En el paquete \textsf{RepoReadWrite} se incluyen las funciones que implementan las transformaciones indicadas en trazo continuo. Por su parte, las transformaciones indicadas con trazo discontinuo pueden implementarse bien con funciones genéricas de lectura y escritura de SAS y R o bien mediante macros SAS programadas \emph{ex profeso} para ello (consúltese la guía del repositorio).\\
 
 El paquete incluye, además, una función auxiliar llamada \textsf{FirstLine} para generar automáticamente la primera línea de los ficheros del repositorio (consúltese la guía del repositorio). Además incluimos una breve discusión sobre la funcionalidad de las funciones \textsf{melt.StBusQ} y \textsf{dcast.StBusQ} para hacer tabulaciones a partir de los ficheros.\\
 
 El paquete contiene datos (objetos de clases data.frame y data.table) para poder evaluar los ejemplos incluidos.\\
 
    \selectlanguage{english}
    \begin{figure}[!htp]
    \begin{center}
    \hspace*{-2cm}
    \begin{tikzpicture}[->,>=stealth', every text node part/.style={align=center}]

         % Position of QUERY
         % Use previously defined 'state' as layout (see above)
         % use tabular for content to get columns/rows
         % parbox to limit width of the listing
         \node[state] (RDM) {\textbf{R}\\\textbf{Data Matrix}\\\textbf{Disk Storage}};
         \node[state, right of= RDM, node distance=7cm, anchor=center] (RKVP) {\textbf{R}\\\textbf{StBusQ}\\\textbf{Main Memory}};
         \node[state, below of= RDM, node distance=4cm, anchor=center] (ADM) {\textbf{ASCII}\\\textbf{Data Matrix}\\\textbf{Disk Storage}};
         \node[state, left of= ADM, node distance=7cm, anchor=center] (SASDM) {\textbf{SAS}\\\textbf{Data Matrix}\\\textbf{Disk Storage}};
         \node[state, below of=RKVP, node distance=4cm, anchor=center] (AKVP) {\textbf{ASCII}\\\textbf{KVP}\\\textbf{Disk Storage}};
         \path (RDM) edge[bend left=15] node[anchor = south, above]{\textsf{melt.StBusQ}} (RKVP);
         \path (RKVP) edge[bend left=15] node[anchor= north, below]{\textsf{dcast.StBusQ}} (RDM);
         \path (RDM) edge[bend left=15, dashed] node[anchor = south, right]{\textsf{Generic R}\\\textsf{Writing Functions}} (ADM);
         \path (ADM) edge[bend left=15, dashed] node[anchor = north,left]{\textsf{Generic R}\\\textsf{Reading Functions}} (RDM);
         \path (RKVP) edge[bend left=15] node[anchor = south, right]{\textsf{WriteRepoFile}} (AKVP);
         \path (AKVP) edge[bend left=15] node[anchor = north, left]{\textsf{ReadRepoFile}} (RKVP);
         \path (SASDM) edge[bend left=15, dashed] node[anchor = south, below, dotted]{} (ADM);
         \path (ADM) edge[bend left=15, dashed] node[anchor= north, below, dotted]{\textsf{SAS Functions}} (SASDM);
         \path (SASDM) edge[bend left=15] node[anchor = north, left]{\textsf{ReadSASFile}} (RDM);
         \path (ADM) edge[bend left=15, dashed] node[anchor= north, below, dotted]{\textsf{SAS Macros}} (AKVP);
         \path (AKVP) edge[bend left=15] node[anchor = north, above, dotted]{\textsf{ReadSASFile}} (ADM);

    \end{tikzpicture}
    \end{center}
    \selectlanguage{spanish}
    \caption{\label{fig:Tra}Transformación entre los diversos formatos y almacenamientos de los ficheros del repositorio.}
    \end{figure}

\section{La función \textsf{ReadSASFile}}

Esta función es básicamente un \emph{wrapper} para la función \textsf{read.sas7bdat} del paquete del mismo nombre. Como parámetros de entrada necesita (i) el nombre del fichero SAS (con la ruta de acceso completa, si es necesario dependiendo del directorio de trabajo); (ii) un data.frame con el contenido de la hoja de cálculo con las correspondencias entre los nombres de las variables en el fichero SAS y los nombres de estas variables para el repositorio y (iii) un data.frame con el contenido del fichero DD para el repositorio con el formato para R. Los nombres de las variables  para el repositorio están fijados en el fichero DD correspondiente del repositorio (consúltese la guía del repositorio); esta correspondencia se está fijando progresivamente entre las unidades promotoras, la SGMRD y la unidad de metodología según las diversas encuestas depositan sus datos en el repositorio. Los parámetros se denotan respectivamente por \textsf{SASFileName}, \textsf{Exceldf} y \textsf{DD}.\\

Para el ejemplo que nos ocupa, el propio paquete trae como ejemplo la correspondencia de las variables en la encuesta de IASS. Cargamos, por tanto, el correspondiente data.frame: 

<<LoadXLS, echo = TRUE>>=
library(RepoReadWrite)
data(XLS)
str(XLS)
@

Alternativamente puede leerse directamente el fichero xls correspondiente del repositorio mediante alguna de las funciones de lectura de ficheros xls en R. Debe tenerse especial cuidado con la diferencia entre mayúsculas y minúsculas, pues cualquier diferencia entre los nombres de las variables en el fichero SAS y en el data.frame \textsf{Exceldf} hará que queden excluidas del output final.\\

Análogamente cargamos el fichero DD y lo transformamos al formato para R:

<<LoadXLS, echo = TRUE>>=
data(RepoDD)
str(RepoDD)
DD <- RepoDDTorDD(RepoDD)
str(DD)
@


Si el fichero SAS de nombre \texttt{MM032014} se encuentra en el escritorio\footnote{El usuario es el administrador.}, para leerlo ejecutamos 

<<ExecReadSAS, echo = TRUE>>=
SASName <- 'C:/Users/Administrador/Desktop/MM032014.sas7bdat'
MM032014.dm <- ReadSASFile(SASName, XLS, DD)
@

El objeto \textsf{MM032014.dm} es una data.table con estructura de matriz de datos (en R, por defecto, todos los objetos se mantienen en la memoria primaria) y con los nombres de las variables y clases respectivas asignados para el repositorio.\\

El tiempo de ejecución de esta función varía dependiendo del tamaño del fichero SAS a importar y de la velocidad de la conexión. Por regla general, ésta es la función que requiere mayor tiempo.

\section{La función \textsf{melt.StBusQ}}

La función \textsf{melt.StBusQ} es básicamente un \emph{wrapper} para la función \textsf{melt.data.table} del paquete \textsf{data.table}. Por ello, presenta la misma funcionalidad, pero adaptada a la estructura de los ficheros del repositorio. Para ello, como parámetros de entrada, además de la matriz de datos de clase data.table a transformar, requiere la especificación del fichero DD correspondiente a la encuesta cuyos ficheros estamos transformando y la estructura del cuestionario como una lista con componentes \textsf{ID}, \textsf{Time}, \textsf{Geo}, \textsf{Class}, \textsf{Object}, \textsf{AuxObject}, que contienen los nombres de las variables con tal contenido semántico.\\

Construimos primeramente la list \textsf{VarList}:

<<ExecVarList, echo = TRUE>>=
VL <- list(ID = c('NOrden'),
           Time = c('IASSAnno', 'IASSMes'),
           Geo = c('IASSCCAA'),
           Class = c('IASSCNAE09', 'IASSRamaCNAE09', 'IASSDivisionCNAE09', 
                     'IASSSectorCNAE09'),
           Object = c('IASSNumDias', 'IASSCifraNeg', 'IASSFactEmp', 'IASSFactHog',
                      'IASSEsExist', 'IASSExist', 'IASSEmpleo_0', 'IASSEmpleo_1_1',
                      'IASSEmpleo_1_2', 'IASSEmpleo_1_3', 'IASSEmpleo_1_4' ),
           AuxObject = c(paste0('IASSLPCifraNeg_', c(paste0('0', 1:9), 10:17)),
                         paste0('IASSLPOcupa_', c(paste0('0', 1:9), 10:17)),
                         'IASSTame', 'IASSAnnoEnt'))
@

Por tanto, para generar el fichero con estructura par clave-valor correspondiente a \textsf{MM032014} tan sólo debemos ejecutar 

<<Execmelt, echo = TRUE>>=
MM032014.Q <- melt.StBusQ(MM032014.dm, DD, VL)
@

El objeto resultante \textsf{MM032014.Q} es un objeto de clase \textsf{StBusQ} con la estructura par clave-valor en el \emph{slot} \textsf{Data}.

\section{La función \textsf{WriteRepoFile}}

Para escribir en disco el objeto anterior tan sólo debemos especificar, además del objeto, el nombre que deseamos darle al fichero en disco y el número de niveles (véase la guía del repositorio). Por tanto, ejecutamos 

<<ExecWriteRepo, echo = TRUE>>=
RepoName <- 'C:/Users/Administrador/Desktop/E30183.FF_V1.MM032014.D_1'
WriteRepoFile(MM032014.Q, Name = RepoName, NIV = 1)
@

El ordenador devuelve un mensaje de confirmación de la escritura.\\

Esta función hace uso de la función \textsf{FirstLine}, que genera automáticamente la primera línea de un fichero con estructura par clave-valor para su inclusión en el repositorio. En nuestro caso, la primera línea sería

<<FirstLine, echo = TRUE>>=
FirstLine(MM032014.Q, NIV =1)
@

\section{El proceso inverso: \textsf{ReadRepoFile} y \textsf{dcastRepo}}

    El paquete \textsf{RepoReadWrite} incluye además funciones para realizar el proceso inverso casi por completo. El último paso de escritura de un fichero SAS no puede realizarse desde R. El primer paso consistiría, pues, en la lectura del fichero en disco con estructura par clave-valor. Para ello se emplea la función \textsf{ReadRepoFile}:
    
    <<ExecReadRepo, echo = TRUE>>=
    RepoName <- 'C:/Users/Administrador/Desktop/E30183.FF_V1.MM032014.D_1'
    FF.MM032014.kv <- ReadRepoFile(RepoName)
    @
    
    El objeto \textsf{FF.MM032014.kv} es de clase data.table con estructura par clave-valor. El tiempo de ejecución de la función depende del tamaño del fichero de lectura (suele ser algo más corto que en el caso de la función \textsf{ReadSASFile}).\\
    
    Seguidamente, podemos emplear la función \textsf{dcast.StBusQ} para pasar al formato de matriz de datos. Nuevamente esta función es básicamente un \emph{wrapper} para la función \textsf{dcast.data.table} del paquete \textsf{data.table}, pero adaptado a la estructura de los ficheros del repositorio. Por ello, como parámetro de entrada, además de la propia data.table con estructura par clave-valor, se necesita proporcionar el fichero DD de la encuesta correspondiente.
    
    <<Execdcast, echo = TRUE>>=
    FF.MM032014.dm <- dcastRepo(FF.MM032014.kv, DD)
    @
    
    Los objetos \textsf{FF.MM032014.dm} y \textsf{MM032014.dm} son iguales, salvo la falta de precisión incurrida en las variables de clase \textsf{numeric} (doble precisión):
    
    <<Comp, echo = TRUE>>=
    # Ordenamos los objetos por NOrden
    setkeyv(FF.MM032014.dm, 'NOrden')
    setkeyv(MM032014.dm, 'NOrden')
    # Ordenamos las columnas
    setcolorder(MM032014.dm, names(FF.MM032014.dm))
    # Comprobamos que no son EXACTAMENTE iguales
    identical(FF.MM032014.dm, MM032014.dm)
    
    # Comprobamos manualmente
    Classes <- unlist(lapply(MM032014.dm, class))
    Mat <- data.frame(NOrden = FF.MM032014.dm[['NOrden']])
    for (col in names(MM032014.dm)){    
        if (Classes[col] == 'numeric') 
            Mat[[col]] <- ifelse( is.na(FF.MM032014.dm[[col]]) & 
                                  is.na(MM032014.dm[[col]]), 
                                  0L,
                 ( abs(FF.MM032014.dm[[col]] - MM032014.dm[[col]]) > 1e-8 ) * 1L )
        if (Classes[col] == 'character') 
            Mat[[col]] <- (FF.MM032014.dm[[col]] != MM032014.dm[[col]]) * 1L    
    }
    all(colSums(Mat)== 0)
    @
    
    Los objetos son iguales hasta una diferencia de $10^{-8}$.

\section{Tabulaciones}

La función \textsf{dcast.data.table} tiene funcionalidades muy útiles, pues permite tabulaciones a discreción. Además, el carácter funcional de R permite agregar en cada celda de la tabulación deseada según la función que especifique el usuario. Veamos varios ejemplos.\\

El punto de partida es la mtriz de datos \textsf{FF.MM032014.dm}. Supongamos que nos interesa conocer la media aritmética de la variable \textsf{ICMCifraNeg} por comunidad autónoma (\textsf{ICMCCAA}) y por grupo (\textsf{ICMGrupoEu}):

<<dcast1a, echo = T>>=
dcast.data.table(FF.MM032014.dm, 
                 ICMCCAA + ICMGrupoEu ~ ., 
                 mean, na.rm = T, 
                 value.var = 'ICMCifraNeg')
@

Alternativamente también puede obtenerse la misma función con

<<dcast1b, echo = T>>=
dcast.data.table(FF.MM032014.dm, 
                 ICMCCAA ~ ICMGrupoEu, 
                 mean, na.rm = T, 
                 value.var = 'ICMCifraNeg')
@

La primera alternativa es más rigurosa desde el punto de vista de la teoría de bases de datos relacionales, por lo que emplearemos tal forma de ahora en adelante.\\

La rapidez del paquete \textsf{data.table} permite complicar las \emph{queries} sin prácticamente afectar al rendimiento. Podemos calcular la media aritmética de la cifra de negocios en alimentación en la comunidad autónoma $13$ para los grupos que no son gasolineras y que están clasificados como gran cadena:

<<dcast1c, echo = T>>=
Subset <- quote(ICMCCAA == '13' & ICMGrupoEu != 'G' & ICMEsGCade == '1')
dcast.data.table(FF.MM032014.dm[eval(Subset)], 
                 ICMCCAA + ICMGrupoEu ~ ., 
                 mean, na.rm = T, 
                 value.var = 'ICMCifraNegAlim')
@

Puesto que la función a emplear es un parámetro de entrada, las opciones son infinitas. Por ejemplo, podemos contabilizar el número de unidades en cada celda:

<<dcast2, echo = T>>=
Count.CCAAGrupo <- dcast.data.table(FF.MM032014.dm, 
                                    ICMCCAA + ICMGrupoEu ~ ., 
                                    length, 
                                    value.var = 'ICMCifraNeg')
Count.CCAAGrupo
sum(Count.CCAAGrupo$V1)
@

De hecho, cuando no se especifica la función, ésta es la opción por defecto:

<<dcast2b, echo = T>>=
Count.CCAAGrupo <- dcast.data.table(FF.MM032014.dm, 
                                    ICMCCAA + ICMGrupoEu ~ ., 
                                    value.var = 'ICMCifraNeg')
Count.CCAAGrupo
sum(Count.CCAAGrupo$N)
@

Podemos también ver los cuantiles (p.ej.\ de orden $p=0.45$)

<<dcast3, echo = T>>=
dcast.data.table(FF.MM032014.dm, 
                 ICMCCAA + ICMGrupoEu ~ ., 
                 quantile, 
                 prob = 0.45, na.rm = T, 
                 value.var = 'ICMCifraNeg')
@

Por el momento, la función \textsf{dcast.data.table} tiene la restricción de que la función \textsf{fun.aggregate} que se pasa como argumento debe tomar un vector como input (y devolver un solo valor como output). No obstante, la versatilidad del paquete \textsf{data.table} permite hacer cálculos programáticamente. Supongamos que queremos calcular la estimación\footnote{El estimador real en ICM es algo más complejo.} $\widehat{\textrm{CN}}=\sum_{k\in s_{i}}\omega_{k}\times\textrm{ICMCifraNeg}_{k}$, donde las celdas $s_i$ están determinadas otra vez por CCAA y grupo:

<<dcast4, echo = T>>=
dcast.data.table(FF.MM032014.dm[, wICMCN := ICMCifraNeg * ICMPesoDis], 
                 ICMCCAA + ICMGrupoEu ~ ., 
                 sum, na.rm = T, 
                 value.var = 'wICMCN')
@

Este tipo de cálculo puede combinarse con los ejemplos anteriores. Supongamos que deseamos el mismo cálculo sólo para las empresas que no están clasificadas como gran superficie ni están en el estrato $4$:

<<dcast5, echo = T>>=
dcast.data.table(FF.MM032014.dm[ICMEstrato != 4 & ICMEsGS == '0']
                               [, wICMCN := ICMCifraNeg * ICMPesoDis], 
                 ICMCCAA + ICMGrupoEu ~ ., 
                 sum, na.rm = T, 
                 value.var = 'wICMCN')
@

Si fuese necesario, pueden programarse más \emph{wrappers} que se ajustasen a necesidades par\-ti\-cu\-la\-res.

\end{document}
